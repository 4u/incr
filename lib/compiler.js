var indentString = require('indent-string');
var selfClosing = require('void-elements');
var filters = require('jade/lib/filters');
var uid = require('./uid');
var Header = require('./header');
var format = require('util').format;

function errorAtNode(node, error) {
  error.line = node.line;
  error.filename = node.filename;
  return error;
}

module.exports = new Compiler;

function Compiler() {
  this.indent = 0;
  this.buffer = null;
  this.options = null;
  this.header = null;
  this.name = '';
  this.header = null;
  this.requires = [];
  this.templates = {
    incremental: '%s(%s)',
    escape: 'escape(%s)'
  };
}

Compiler.prototype.setTemplate = function(name, template) {
  if (name in this.templates) {
    this.templates[name] = template;
  } else {
    throw new Error('Undefined template name: ' + name);
  }
};

Compiler.prototype.setRequires = function(list) {
  this.requires = list || [];
};

Compiler.prototype.push = function(str) {
  this.buffer.push(indentString(str, ' ', this.indent * 2));
};

Compiler.prototype.incr = function(name, params) {
  return format(this.templates.incremental, name, params);
};

Compiler.prototype.ipush = function(name, params) {
  this.push(this.incr(name, params) + ';');
};

Compiler.prototype.escape = function(param) {
  return format(this.templates.escape, param);
};

Compiler.prototype.compile = function(tokens, options) {
  this.buffer = [];
  this.header = new Header(this.requires);
  this.indent = -1;
  this.options = options || {};
  this.name = '';
  this.visit(tokens);

  if (!this.header.name && !this.buffer.length) {
    return '';
  }

  return [
    '// AUTOGENERATED FILE. DO NOT CHANGE!',
    this.header.toBuffer().join('\n'),
    '',
    '',
    '/** @param {Object} d */',
    this.header.name + ' = function(d) {',
      indentString(this.buffer.join('\n'), ' ', 2),
    '};',
    ''
  ].join('\n');
};

Compiler.prototype.visit = function(node) {
  if (!this['visit' + node.type]) {
    console.log(node);
    throw errorAtNode(node, 'Undefined node type:' + node.type);
  }
  return this['visit' + node.type](node);
};

Compiler.prototype.visitBlock = function(block) {
  this.indent++;
  block.nodes.forEach(this.visit, this);
  this.indent--;
};

Compiler.prototype.visitCase = function(node) {
  this.push('switch (' + node.expr + ') {');
  this.visit(node.block);
  this.push('}');
};

Compiler.prototype.visitWhen = function(node) {
  if ('default' == node.expr) {
    this.push('default:');
  } else {
    this.push('case ' + node.expr + ':');
  }
  if (node.block) {
    this.visit(node.block);
    this.push('  break;');
  }
};

Compiler.prototype.visitLiteral = function(node) {
  this.push(node.str);
},

Compiler.prototype.visitTag = function(tag) {
  var attrBlocks = tag.attributeBlocks.slice();
  var attrs = this.attrs(tag.attrs);
  attrs = (attrs.key || '""') + ', ' + this.statics(attrs);

  if (tag.selfClosing || selfClosing[tag.name]) {
    this.ipush('elementVoid', '"' + tag.name + '", ' + attrs);
    this.visitAttributeBlocks(attrBlocks);
  } else {
    if (attrBlocks.length > 0) {
      this.ipush('elementOpenStart', '"' + tag.name + '", ' + attrs);
      this.visitAttributeBlocks(tag.attributeBlocks.slice());
      this.ipush('elementOpenEnd', '"' + tag.name + '"');
    } else {
      this.ipush('elementOpen', '"' + tag.name + '", ' + attrs);
    }
    if (tag.code) {
      this.visitCode(tag.code);
    }
    this.visit(tag.block);
    this.ipush('elementClose', '"' + tag.name + '"');
  }
};

Compiler.prototype.visitFilter = function(filter) {
  var text = filter.block.nodes.map(function(node){
    return node.val
  }).join('\n');

  filter.attrs.filename = this.options.filename;

  try {
    if (!this.header.filter(filter.name, text, filter.attrs)) {
      this.push(filters(filter.name, text, filter.attrs), true);
    }
  } catch (err) {
    throw errorAtNode(filter, err);
  }
},

Compiler.prototype.visitText = function(text) {
  this.ipush('text', '"' + text.val.replace(/"/g, '\\"') + '"');
};

Compiler.prototype.visitComment = function(comment) {
  if (!comment.buffer) return;
  this.push('/*' + comment.val + '*/');
},

Compiler.prototype.visitBlockComment = function(comment) {
  if (!comment.buffer) return;
  this.push('/*' + comment.val);
  this.visit(comment.block);
  this.buffer('*/');
},

Compiler.prototype.visitCode = function(code) {
  if (code.buffer) {
    var val = code.val.trim();
    if (code.escape) val = this.escape(val);
    this.ipush('text', val);
  } else {
    this.push(code.val);
  }

  if (code.block) {
    if (!code.buffer) this.push('{');
    this.visit(code.block);
    if (!code.buffer) this.push('}');
  }
};

Compiler.prototype.visitAttributeBlocks = function(attributeBlocks) {
  if (attributeBlocks) {
    attributeBlocks.forEach(function(block) {
      var name = uid();
      this.push('var ' + name + ' = ' + block + ';');
      var key = uid();
      this.push(format('for (var %s in %s) { attr(%s, %s[%s]); }',
          key, name, key, name, key));
    }, this);
  }
};

Compiler.prototype.attrs = function(attrs) {
  return attrs.reduce(function(rv, attr) {
    var value = attr.val;
    var name = attr.name;

    if (name === 'class') {
      if (rv[name]) {
        rv[name].push(value);
      } else {
        rv[name] = [value]
      }
    } else {
      rv[name] = value;
    }
    return rv;
  }, {});
}

Compiler.prototype.statics = function(attrs) {
  var statics = [];
  Object.keys(attrs || {}).forEach(function(name) {
    var value = attrs[name];
    if (name === 'class') {
      if (value.length > 1) {
        value = '[' + value.join(', ') + '].join(" ")'
      } else {
        value = value[0];
      }
    }
    if (name !== 'key') {
      statics.push('"' + name + '"', value);
    }
  }, this);

  if (statics.length === 0) {
    return 'null';
  }
  return '[' + statics.join(', ') + ']';
};
